#!/bin/bash

# 라인별 코드 리뷰 자동화 스크립트
# GitHub API를 사용하여 PR에 라인별 코멘트 추가

set -e

# 설정
PR_NUMBER="${1:-}"
if [ -z "$PR_NUMBER" ]; then
    echo "❌ 사용법: $0 <PR_NUMBER>"
    exit 1
fi

# GitHub 정보 추출 (jq 없이)
REPO_URL=$(gh repo view --json url | grep -o '"url":"[^"]*"' | cut -d'"' -f4)
OWNER=$(echo "$REPO_URL" | cut -d'/' -f4)
REPO=$(echo "$REPO_URL" | cut -d'/' -f5)

echo "🔍 PR #$PR_NUMBER 분석 중..."

# PR 정보 가져오기
PR_INFO=$(gh pr view "$PR_NUMBER" --json headRefOid,files)
COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.headRefOid')

# 변경된 파일 목록 및 diff 가져오기
echo "📋 변경된 파일 분석 중..."
gh pr diff "$PR_NUMBER" > pr_diff.txt

# 리뷰 코멘트를 저장할 임시 파일
REVIEW_COMMENTS_FILE="review_comments.json"

# 리뷰 코멘트 JSON 초기화
cat > "$REVIEW_COMMENTS_FILE" << EOF
{
  "commit_id": "$COMMIT_SHA",
  "event": "COMMENT",
  "body": "## 🤖 자동 라인별 코드 리뷰\\n\\n이 리뷰는 Claude Code가 자동으로 생성했습니다.",
  "comments": []
}
EOF

# 코드 분석 및 리뷰 규칙 정의
analyze_code() {
    local file_path="$1"
    local file_content="$2"
    local comments=""
    
    # 파일 확장자 확인
    extension="${file_path##*.}"
    
    case "$extension" in
        kt|java)
            # Kotlin/Java 파일 분석
            # 하드코딩된 값 검색
            if echo "$file_content" | grep -n "apiKey.*=.*\"" > /dev/null; then
                line_num=$(echo "$file_content" | grep -n "apiKey.*=.*\"" | head -1 | cut -d: -f1)
                comments=$(cat <<-END
{
  "path": "$file_path",
  "line": $line_num,
  "body": "🔒 **보안 이슈**: 하드코딩된 API 키가 발견되었습니다.\\n\\n환경 변수나 설정 파일을 사용하세요:\\n\`\`\`kotlin\\nprivate val apiKey = System.getenv(\"API_KEY\")\\n\`\`\`\\n\\n🤖 Generated by Claude Code"
}
END
                )
            fi
            
            # SQL 인젝션 취약점 검색
            if echo "$file_content" | grep -n "SELECT.*WHERE.*\\\$" > /dev/null; then
                line_num=$(echo "$file_content" | grep -n "SELECT.*WHERE.*\\\$" | head -1 | cut -d: -f1)
                if [ -z "$comments" ]; then
                    comments=$(cat <<-END
{
  "path": "$file_path",
  "line": $line_num,
  "body": "⚠️ **보안 취약점**: SQL 인젝션 가능성이 있습니다.\\n\\nPreparedStatement 사용을 권장합니다:\\n\`\`\`kotlin\\nval query = \"SELECT * FROM users WHERE id = ?\"\\n\`\`\`\\n\\n🤖 Generated by Claude Code"
}
END
                    )
                fi
            fi
            
            # 입력 검증 누락
            if echo "$file_content" | grep -n "@RequestBody.*String" > /dev/null; then
                line_num=$(echo "$file_content" | grep -n "@RequestBody.*String" | head -1 | cut -d: -f1)
                if [ -z "$comments" ]; then
                    comments=$(cat <<-END
{
  "path": "$file_path",
  "line": $line_num,
  "body": "💡 **개선 제안**: 입력 검증을 추가하세요.\\n\\nDTO 클래스와 검증 어노테이션 사용 권장:\\n\`\`\`kotlin\\n@Valid @RequestBody userData: UserDto\\n\`\`\`\\n\\n🤖 Generated by Claude Code"
}
END
                    )
                fi
            fi
            ;;
            
        md)
            # Markdown 파일 분석
            # TODO 항목 확인
            if echo "$file_content" | grep -n "TODO\|FIXME" > /dev/null; then
                line_num=$(echo "$file_content" | grep -n "TODO\|FIXME" | head -1 | cut -d: -f1)
                comments=$(cat <<-END
{
  "path": "$file_path",
  "line": $line_num,
  "body": "📝 **알림**: TODO 항목이 발견되었습니다.\\n\\n완료 후 체크리스트를 업데이트해주세요.\\n\\n🤖 Generated by Claude Code"
}
END
                )
            fi
            ;;
            
        yml|yaml)
            # YAML 파일 분석
            # 보안 설정 확인
            if echo "$file_content" | grep -n "ANTHROPIC_API_KEY\|secrets\." > /dev/null; then
                line_num=$(echo "$file_content" | grep -n "ANTHROPIC_API_KEY\|secrets\." | head -1 | cut -d: -f1)
                comments=$(cat <<-END
{
  "path": "$file_path",
  "line": $line_num,
  "body": "✅ **Good Practice**: 시크릿 관리가 적절히 구성되어 있습니다.\\n\\nGitHub Secrets를 통한 안전한 관리 확인됨.\\n\\n🤖 Generated by Claude Code"
}
END
                )
            fi
            ;;
    esac
    
    echo "$comments"
}

# 변경된 파일별로 분석
echo "🔍 파일별 분석 시작..."
COMMENTS_JSON="[]"

# PR의 변경된 파일 목록 가져오기
FILES=$(gh pr view "$PR_NUMBER" --json files | jq -r '.files[].path')

for file in $FILES; do
    echo "  📄 분석 중: $file"
    
    # 파일이 존재하는지 확인
    if [ -f "$file" ]; then
        # 파일 내용 읽기
        file_content=$(cat "$file")
        
        # 코드 분석 실행
        comment=$(analyze_code "$file" "$file_content")
        
        # 코멘트가 있으면 JSON에 추가
        if [ -n "$comment" ]; then
            # jq를 사용하여 JSON 배열에 추가
            COMMENTS_JSON=$(echo "$COMMENTS_JSON" | jq ". += [$comment]")
            echo "    💬 리뷰 코멘트 생성됨"
        fi
    fi
done

# 최종 리뷰 JSON 생성
jq --argjson comments "$COMMENTS_JSON" '.comments = $comments' "$REVIEW_COMMENTS_FILE" > review_final.json

# 코멘트가 있는지 확인
COMMENT_COUNT=$(echo "$COMMENTS_JSON" | jq 'length')

if [ "$COMMENT_COUNT" -eq 0 ]; then
    echo "✅ 자동 분석 결과 특별한 이슈가 발견되지 않았습니다."
    
    # 전체 리뷰만 추가
    gh pr review "$PR_NUMBER" --comment --body "$(cat <<-EOF
## 🤖 자동 코드 리뷰 완료

### ✅ 분석 결과
- 자동 검사에서 특별한 이슈가 발견되지 않았습니다.
- 코드 품질이 양호합니다.

### 📋 검토 항목
- 🔒 보안 취약점: 발견되지 않음
- ⚡ 성능 이슈: 발견되지 않음  
- 📝 코드 스타일: 양호

---
🤖 Generated by [Claude Code](https://claude.ai/code)
EOF
    )"
else
    echo "📝 $COMMENT_COUNT 개의 리뷰 코멘트 생성"
    echo "🚀 GitHub API로 리뷰 제출 중..."
    
    # GitHub API를 사용하여 리뷰 제출
    gh api \
        --method POST \
        -H "Accept: application/vnd.github+json" \
        -H "X-GitHub-Api-Version: 2022-11-28" \
        "/repos/$OWNER/$REPO/pulls/$PR_NUMBER/reviews" \
        --input review_final.json
    
    echo "✅ 라인별 코드 리뷰가 성공적으로 추가되었습니다!"
fi

# 임시 파일 정리
rm -f pr_diff.txt "$REVIEW_COMMENTS_FILE" review_final.json

echo "🎉 리뷰 프로세스 완료!"